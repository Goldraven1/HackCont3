# Logstash конфигурация для обработки логов
# Электронный журнал производства работ - Промышленное решение

# Входные источники данных
input {
  # Логи Django основного сервиса
  beats {
    port => 5044
    type => "django-logs"
  }
  
  # Логи FastAPI сервисов
  beats {
    port => 5045
    type => "fastapi-logs"
  }
  
  # Системные логи контейнеров
  docker {
    ports => [5000]
    codec => json
    type => "docker-logs"
  }
  
  # Логи Nginx
  file {
    path => "/var/log/nginx/*.log"
    type => "nginx-logs"
    start_position => "beginning"
    codec => multiline {
      pattern => "^\d{4}/\d{2}/\d{2}"
      negate => true
      what => "previous"
    }
  }
  
  # Логи PostgreSQL
  file {
    path => "/var/log/postgresql/*.log"
    type => "postgres-logs"
    start_position => "beginning"
  }
  
  # Логи Redis
  file {
    path => "/var/log/redis/*.log"
    type => "redis-logs"
    start_position => "beginning"
  }
  
  # Структурированные логи приложения (JSON)
  tcp {
    port => 5000
    codec => json_lines
    type => "application-logs"
  }
  
  # UDP логи для высокой производительности
  udp {
    port => 5001
    codec => json
    type => "performance-logs"
  }
  
  # Syslog для системных событий
  syslog {
    port => 5140
    type => "syslog"
  }
  
  # HTTP input для веб-хуков
  http {
    port => 8080
    codec => json
    type => "webhook-logs"
  }
}

# Фильтры для обработки и парсинга логов
filter {
  # Общие поля для всех логов
  mutate {
    add_field => {
      "environment" => "production"
      "service_name" => "electronic-journal"
      "parsed_timestamp" => "%{@timestamp}"
    }
  }
  
  # Парсинг Django логов
  if [type] == "django-logs" {
    grok {
      match => { 
        "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{LOGLEVEL:level}\] %{DATA:logger_name}: %{GREEDYDATA:log_message}"
      }
    }
    
    # Парсинг JSON структур в Django логах
    if [log_message] =~ /^\{.*\}$/ {
      json {
        source => "log_message"
        target => "django_data"
      }
    }
    
    # Определение критичности события
    if [level] == "ERROR" or [level] == "CRITICAL" {
      mutate { add_tag => ["error", "alert"] }
    }
    
    # Парсинг информации о пользователе
    grok {
      match => { 
        "log_message" => "User\s+(?<user_id>\d+)\s+(?<user_action>\w+)"
      }
      tag_on_failure => ["_grokparsefailure_user"]
    }
    
    # Парсинг SQL запросов
    grok {
      match => { 
        "log_message" => "SQL:\s+(?<sql_query>.*?);\s+\((?<query_time>\d+\.\d+)s\)"
      }
      tag_on_failure => ["_grokparsefailure_sql"]
    }
  }
  
  # Парсинг FastAPI логов
  if [type] == "fastapi-logs" {
    json {
      source => "message"
      target => "fastapi_data"
    }
    
    # Извлечение метрик производительности
    if [fastapi_data][request_time] {
      mutate {
        convert => { "[fastapi_data][request_time]" => "float" }
      }
      
      # Помечаем медленные запросы
      if [fastapi_data][request_time] > 1.0 {
        mutate { add_tag => ["slow_request"] }
      }
    }
    
    # Парсинг HTTP статусов
    if [fastapi_data][status_code] {
      mutate {
        convert => { "[fastapi_data][status_code]" => "integer" }
      }
      
      if [fastapi_data][status_code] >= 400 {
        mutate { add_tag => ["http_error"] }
      }
      
      if [fastapi_data][status_code] >= 500 {
        mutate { add_tag => ["server_error", "alert"] }
      }
    }
  }
  
  # Парсинг Nginx логов
  if [type] == "nginx-logs" {
    grok {
      match => { 
        "message" => '%{IPORHOST:client_ip} - %{DATA:user_name} \[%{HTTPDATE:access_time}\] "%{WORD:http_method} %{DATA:url} HTTP/%{NUMBER:http_version}" %{NUMBER:response_code} %{NUMBER:body_sent} "%{DATA:referrer}" "%{DATA:agent}" rt=%{NUMBER:request_time} uct="%{DATA:upstream_connect_time}" uht="%{DATA:upstream_header_time}" urt="%{DATA:upstream_response_time}"'
      }
    }
    
    mutate {
      convert => { 
        "response_code" => "integer"
        "body_sent" => "integer"
        "request_time" => "float"
      }
    }
    
    # Классификация по типам запросов
    if [url] =~ /^\/api\/.*/ {
      mutate { add_tag => ["api_request"] }
    }
    
    if [url] =~ /^\/files\/.*/ {
      mutate { add_tag => ["file_request"] }
    }
    
    if [url] =~ /^\/gis\/.*/ {
      mutate { add_tag => ["gis_request"] }
    }
    
    # Анализ ошибок
    if [response_code] >= 400 {
      mutate { add_tag => ["nginx_error"] }
    }
    
    if [response_code] >= 500 {
      mutate { add_tag => ["nginx_server_error", "alert"] }
    }
    
    # Анализ производительности
    if [request_time] > 5.0 {
      mutate { add_tag => ["slow_nginx_request"] }
    }
  }
  
  # Парсинг PostgreSQL логов
  if [type] == "postgres-logs" {
    grok {
      match => { 
        "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{NUMBER:pid}\] %{LOGLEVEL:level}:\s+%{GREEDYDATA:postgres_message}"
      }
    }
    
    # Парсинг медленных запросов
    grok {
      match => { 
        "postgres_message" => "duration:\s+(?<query_duration>\d+\.\d+)\s+ms\s+statement:\s+(?<sql_statement>.*)"
      }
      tag_on_failure => ["_grokparsefailure_postgres_slow"]
    }
    
    if [query_duration] {
      mutate {
        convert => { "query_duration" => "float" }
      }
      
      if [query_duration] > 1000.0 {
        mutate { add_tag => ["slow_query", "performance_issue"] }
      }
    }
    
    # Анализ ошибок подключения
    if [postgres_message] =~ /connection/ {
      mutate { add_tag => ["connection_event"] }
    }
    
    if [level] == "ERROR" or [level] == "FATAL" {
      mutate { add_tag => ["postgres_error", "alert"] }
    }
  }
  
  # Парсинг логов приложения (структурированные)
  if [type] == "application-logs" {
    # Извлечение информации о бизнес-событиях
    if [event_type] == "journal_entry_created" {
      mutate { add_tag => ["business_event", "journal_activity"] }
    }
    
    if [event_type] == "project_status_changed" {
      mutate { add_tag => ["business_event", "project_activity"] }
    }
    
    if [event_type] == "document_uploaded" {
      mutate { add_tag => ["business_event", "document_activity"] }
    }
    
    if [event_type] == "user_login" or [event_type] == "user_logout" {
      mutate { add_tag => ["security_event", "user_activity"] }
    }
    
    # Анализ безопасности
    if [event_type] == "authentication_failed" {
      mutate { add_tag => ["security_alert", "auth_failure"] }
    }
    
    if [event_type] == "unauthorized_access" {
      mutate { add_tag => ["security_alert", "access_violation", "alert"] }
    }
  }
  
  # GeoIP обогащение для внешних IP
  if [client_ip] and [client_ip] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.)/ {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }
  
  # Обогащение User-Agent
  if [agent] {
    useragent {
      source => "agent"
      target => "user_agent"
    }
  }
  
  # Нормализация временных меток
  date {
    match => [ "timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss,SSS", "dd/MMM/yyyy:HH:mm:ss Z" ]
    target => "@timestamp"
  }
  
  # Удаление ненужных полей для экономии места
  mutate {
    remove_field => [ "host", "agent", "message" ]
  }
  
  # Добавление индекса на основе типа и даты
  mutate {
    add_field => { 
      "index_name" => "electronic-journal-%{type}-%{+YYYY.MM.dd}"
    }
  }
}

# Выходные данные
output {
  # Основной вывод в Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "%{index_name}"
    template_name => "electronic-journal"
    template_pattern => "electronic-journal-*"
    template => "/usr/share/logstash/templates/electronic-journal-template.json"
    manage_template => true
    
    # Настройки производительности
    flush_size => 500
    idle_flush_time => 5
    workers => 2
  }
  
  # Алерты для критических событий
  if "alert" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "electronic-journal-alerts-%{+YYYY.MM.dd}"
    }
    
    # Отправка в Webhook для уведомлений
    http {
      url => "http://core_service:8000/api/v1/alerts/webhook"
      http_method => "post"
      content_type => "application/json"
      format => "json"
      mapping => {
        "timestamp" => "%{@timestamp}"
        "level" => "%{level}"
        "message" => "%{log_message}"
        "service" => "%{type}"
        "tags" => "%{tags}"
      }
    }
  }
  
  # Метрики производительности
  if "performance-logs" in [type] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "electronic-journal-metrics-%{+YYYY.MM}"
    }
  }
  
  # Бизнес-события для аналитики
  if "business_event" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "electronic-journal-business-%{+YYYY.MM}"
    }
  }
  
  # События безопасности
  if "security_event" in [tags] or "security_alert" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "electronic-journal-security-%{+YYYY.MM.dd}"
    }
  }
  
  # Отладочный вывод (только для разработки)
  if [type] == "debug" {
    stdout { 
      codec => rubydebug 
    }
  }
  
  # Резервное сохранение в файл для критических данных
  if "alert" in [tags] or "security_alert" in [tags] {
    file {
      path => "/var/log/logstash/alerts/alert-%{+YYYY-MM-dd}.log"
      codec => json_lines
    }
  }
}
